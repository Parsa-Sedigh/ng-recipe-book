<!-- Running npm i <package> will install the LATEST version of that package.
When you add a new production dependency (a dependency that is crucial for running the project), you need to inform the
 angular cli that the newly installed package must be included into the final bundle that it creates. Because the cli bundles
 all of our script files and also the style files and by default it would not include that newly installed package.
 Important: So to inform CLI about the new installed package which is crucial for running the app, we should go to angular.json file
  and in case of added bootstrap package, in styles array, we can add a new global stylesheet that we want to add to our whole
  project.Also from the beginning in styles array, you have styles.css file which is the styles for whole project.
  ALSO REMEMBER TO ADD THE 3rd party packages BEFORE your files. So for example we must add the path to bootstrap file BEFORE
  the path to our styles.css file.
  In bootstrap file, the min version is lying inside the main version so instead of: .../bootstrap.css/bootstrap.min.css you must
  say: .../bootstrap.min.css . So we learnt that is better to include the path to minified versions of 3rd party packages in
  our config files like angular.json .

Not every component should have a folder on the root level of app folder. You should also nest the components based on their feature
inside each other.
Remember: you have to register all of the features you're going to use, in app.module.ts file.

To prevent the creation of .spec.ts file when you are creating components using cli, you can use --skipTests true .

If you don't want to create the new component inside app folder when creating a new component with cli, you can easily tell cli to
create that component in a sub directory by basically passing a path with the name of that new component. So it should be like:
ng g c recipes/recipe-list --skipTests true but that recipes directory which is the parent directory of our new component must
exist before. Now the last command will create recipe-list component inside recipes directory.

We nest the recipe-item folder inside recipe-list because a recipe item is just one item in the list of recipes which is recipe-list .
  -->
<!-- We need to pass data between components.
 We can use property in event biding not only on html elements and their native attrs and events, but we can use it on directives
 and we also did this with ngClass and ngStyle. So we can use it on our own components and bind it to our won custom properties
 and custom events.
 So property and event binding can be done on 3 things:
 1) HTML elements 2)Directives 3) Components
 For HTML elements we bind to their natural attr and events but for those other two, we bind to their custom properties and
 events.

 So we can use property binding to bind to component properties.

 property: {} With this syntax we make sure that this property just get the type that is defined inside {} .
 SO {...} is not the value of property.

 Binding to a property of a component outside of folder of component (binding to a custom property):

 Let's assume that we have a property in the class of our component and we want to bind to this property outside of folder of
 our component. So it would be like: [component] = "..." , now this would throw an error and the error would say: 'Can't bind to
 <property>, since it isn't a known property of <selector of component>'. You might say. That isn't true. We defined that property
 to be a property of it's class.It's even public because I even didn't manipulate the accessor of that property. But the problem
 is by default all properties of components are only accessible INSIDE of their components and not from outside.So:
 By default we can't access properties in components from other components(even from app component we can't access properties
 of other components) and generally this is a good thing. Because we don't want to make all of our properties bindable from outside.
 So you have to be explicit about which properties you want to expose to other components.
 So if you want to allow parent components to be able to bind to this property, you need to add something to that property of
 component. A decorator. So we learnt that decorators are not only available for classes. So here we're going to add a decorator
 to a property of component. The decorator in this case we want to use is @Input and here we need to execute it, like a function.
 So in the end of decorator add (). Now we need to import that decorator from '@angular/core'. So for example:
 @Input <property>: ...;
 With these things, now we are successfully exposing this property to the world! So now any parent component of this component
 which has a @Input() for it's property, is now be able to bind to that exposed property.

 When a component is parent of another component, we say that parent component is hosting that child component or is
 implementing that child component through it's selector.

 IMPORTANT: You can only use the properties of a component in template of parent components JUST ON THE INSTANCE OF THAT
  component not on other component. For example if the selector of component is: app-server and it's exposed property is
  @Input x; and you want to bind this property in the parent component of this component, YOU MUST FIRST INSTANCIATE this
  component and then use this property on that instance not anywhere else.
  We instanciate a component by using it's selector.So if the selector is: 'app-server' , we instanciate this component
  by saying: <app-server [x] = "<a expression which maybe it's result's would change>"></app-server>
  So here, we're binding an exposed property of a child component in parent component and we know that when you bind a property,
  the value of that property would change based on the thing that is in ""(double quotes). So for example, in above piece of
  code we binded x which is an exposed of property of a child component to "<...>" . So as you can see that expression which is
  inside "" , can affect the x property. In other words we're changing the property of child component. So parent component is
  affecting the properties of child component with property binding of child component.
  Now you only can the properties of this component ONLY ON <app-server> not anywhere else.
  So this was custom property binding.

  Now custom event binding:
  In this kind of binding, we want to inform the parent component(which implements child components) of this component,
  So we want to emit our own event to inform the parent component. So it would be good if in the template of parent component or
  in other words the place we implement that child component, we could listen to a custom event which is in the child component
  and on the right side of equal sign, we would execute some code after that event was triggered. For example we would call
  a method which is defined in the parent component once the custom event which is defined in the child component is triggered
  and also we can catch the data which was emitted because of triggering the custom event.
  What is crucial is that the custom events which are defined in child component are PROPERTIES THAT WE CAN EMIT THEM LIKE
  THEY ARE SOME KIND OF EVENT. Of course we want to have an access to these properties from parent components of this child
  component but instead of using @Input() for these properties to mark them as properties that we can have access them from
  parents of this component, instead, we want to do the opposite! We want to mark these properties that like they are kind of
  events which we can emit them. So for making them an event, we need to assign them a new object of EventEmitter() class,
  then we need to import EventEmitter from '@angular/core'.
  So EventEmitter is a class that we can instanciate an object from it which allows you to emit your own events.
  Now you can use .emit() method on those event properties and pass that method some stuff that can be received in
  parent component, using $event variable.
  But currently one piece is missing. Remember that we added @Input() to make a property, bindable from outside to change
  that property from it's components. So now we need to add something to these properties to make them listenable from
  their parent components. So we need to use @Output() decorator and import it. Because we're passing our custom events OUT of
  this component. So the name of this decorator is right.

  RECAP:
  A)
  Now our components can communicate with each other. The first kind of communicate is parent to child and we ca  do it
  by binding properties of child component in parent component to some code and by executing that some code, we can change
  or affect the properties of that child component. So in this kind of communicate the parent component is affecting the child
  component by binding the properties of child component in template of parent component. So in this kind of communicate,
  the parent component can communicate with child component by executing some code in "" of right side of binding the
  property of child component.
  Example:
  [<A property of child component>] = "<an expression that maybe pass some data to child component or other kinds of work>"

  B)
  Another kind of communicate is that child component can affect the parent component or in other words can send or emit
  some data to parent component by making the properties of child component, a custom event which can emit some data.
  So now other components can listen to your custom event.
  Example:
  (the property of child component which is a custom event that emits some data) = "<a method of parent component which gets
  the data that the property of child component emits by passing it the $event variable and in defenition of this
  method in .ts file of parent component, we can receive this $event variable by passing the definition of method an arg with
  any name>"

  EventEmitter is a generic type which is indicated in typescript by using <> and in between those <> , you simply define
  the type of event data you're going to emit.

  You can pass in a name in parentheses of @Output to use that name in parent components and use the real name of property inside
  that component.

  It can get complicated to emit an event in child component and receive that data which that event emits and then maybe
  change something in parent component and pass some data down to child component.So these chains of inputs and outputs
  can grow complex.
  So There are some use cases where the distance between two components that should talk to each other is so long so building a
  chain of inputs and outputs would be complex. So in services we have another approach of having components talk to each other.


  -->
<!-- Assigning an alias to custom properties:
 You can pass an argument to @input with the property name that you want to use that new name of property outside of
 that component. So: @Input(property2) <property1>: ...;
 So in this example, we still use property1 name in that folder of component, but now we MUST use property2 in the components
 that implement this component(parent components of this component).-->
<!--  We know that css normally doesn't really care in which css file you define a rule, it simply is applied to
      the whole document NORMALLY. BUT WHEN YOU ARE USING ANGULAR, THIS NORMAL BEHAVIOR OF CSS DOESN'T WORK ANYMORE.
      Important: So every css file is just for that specific component and no other component. Even if you select all
       <p> elements in css file of one component, that rule won't apply to <p> elements in other components. This behavior
       is ENFORCED by angular. Why enforced? Because the default behavior of css is opposite of this behavior.
       So we can say, each css file for components, encapsulate the styles for that specific component.

       For example, when you select .p {...} in the css file for one component, because of default behavior of css it would
       apply to whole application. But angular doesn't want this. So it had to add an attribute for each component to make
       the styles of each component, specific for that component and not anything else. That attribute is special for
       each component and it would be like: [_ngcontent-ejo-<i>] . i can be 1 2 or ... .
       So all of the html elements which are in one component, have a specific attribute like above. So when we add css rules
       in css files, angular add that special attribute to all of the html elements which are in one component, therefore
       the styles that we define in css file of a component, ONLY apply to html elements in DOM which have that attribute.
       So in DOM, we have elements with [_ngcontent-ejo-3] so we find out those elements are for one component and will
       share one specific css file which is only for that component.

       So we find out angular enforces css encapsulation, but it can't do this encapsulation magically right?!
       So what does it do is it simply gives the same attr to all html elements in a component and it does it for each
       component with different unique attr and also it would give all of the selectors that are in css file of a component
       that exact attr which it gave to elements that are in that component, so those styles only get applied to elements of
       that component and no other component.
       So if angular gives attr of [_ngcontent-ejo-3] to all of the html elements of a component, it also adds this
       [_ngcontent-ejo-3] attr to all of the selectors of the css file of that component to make sure ONLY the elements if
       that component receive those styles and no other elements in other components. This is how angular enforce that behavior.
       It kind of emulates the shadow DOM. The shadow DOM is a technology which is not supported by akk browsers. In shadow
       DOM, each element has it's own shadow DOM behind it. But here it kind of simulate this shadow dom by using attrs.

       You can override the encapsulation of styles for each component. For this, you can add sth to @Component in .ts file
       of component. It's a property in object of @Component and it's called: encapsulation and for value, you give
       ViewEncapsulation which ViewEncapsulation needs to be imported from '@angular/core' and then you can choose between
       3 modes of ViewEncapsulation. emulated is default one. If you say ViewEncapsulation.None , now the component which has
       encapsulation: ViewEncapsulation.None hasn't the view encapsulation anymore, so it's elements and css rules haven't
       special attr anymore. Now if you declare styles in this component, if those styles are applicable by elements with even
       a special attr, they will ALSO get that style which is defined in another component!
       So imagine we have a component which has ViewEncapsulation.None and in it's styles we declared:
       P {
        color: "blue";
       }

       .someClass {
        ...
       }

       The styles which are in p selector would apply to all of the <p> elements that are in other components. But the
       styles for .someClass , would also applicable to elements in other components IF they have this class.
       So by using ViewEncapsulation.None , all of the styles which are in css file of that component have potential of
       being used in other components even in other components we would have a special attr for their elements and their
       css code.
       Because when you for example select .p in css and give it some styles, it doesn't matter an element has a special
       attribute. Because .p will MATCH that p element with special attr so it would apply to that element even if that
       element is in another component. But if the selector would be: .p [<special attr>] , this selector would match with
       p elements that have this special attr.

       ViewEncapsulation.Native uses the shadow DOM technology. This should gives you the same result as before with emulated
       but only in browsers that support . So in most cases you would use ViewEncapsulation.Emulated which you don't need
       to use this because it's the default behavior.

       RECAP: So by default, ONLY YOUR component would receives the styles that you define for it and not other components.-->
<!-- Using local references in templates:
 If you don't want to use two-way data binding in a template file, so instead of using [(NgModel)] = "..." , we can use
 local reference on that element. A local reference can be placed on any html element.
 Learn: So when you define a local reference on an element, that reference will hold a reference to the element that it is
  defined on that element. So it's a reference to that WHOLE HTML element with all it's properties and not just only
  a reference to the value of that HTML element(for example we defined it on <input>).
  The type of a local reference is: HTMLElementInput

  Now you can use that local reference everywhere on that exact template and not in /ts file or not anywhere else. But
  for example you can pass that local reference to () of a method call in that template and use that local reference in
  .ts file, where you define that method, bu defining an arg for that method to receive that local reference.

  Recap: A local reference is a very nice feature to get access to some elements in your template and then use that reference
  either directly in that template or you can pass it to a method call and ... .

  So for getting using the local reference we just write it's name without #.
  -->
<!-- Getting access to template and DOM using @ViewChild:
 There's also another way of getting access to local references or in other words to any element actually. But with this
 approach we can also access that reference DIRECTLY from .ts code . Right now we can only use the local reference in .ts code
 by actually calling a method in template and pass the local reference to that method which is defined in .ts code and
 receive it in .ts code by defining the method an arg. But sometimes you want to access that local reference. before
 calling that method. For be able to do this, we must add a property to the in class of .ts file by adding it a decorator
 called @ViewChild() and then import it from '@angular/core'. But @ViewChild() like this, won't work. We need to pass it
 an argument and that arg is how we want to select that html element in .ts file. But not like a css selector, but we can
 pass in the name of the local reference that we used on that element to @ViewChild('<name of local reference of that element
 we want it in this .ts file>', {static: true}) decorator. But also you can select that element by passing the type of
 component not as a string. So for example if we have shopping-list component, we would pass in shopping-list (not as a string)
 to @ViewChild() . But important: it will only select the first occurance of that element in template file.
 So it's better to use the local reference of that element which we want to access it in .ts file instead of type of that
 component. Because the goal of all of doing this, is to make components communicate to each other.
 But now the difference between passing the local reference to a method of .ts class and passing local reference of
 that element which we want to use it in .ts file, to @ViewChild() , is in the first approach, the type of local reference in
 first approach is HTMLElementInput but in second approach the type of property that you were used
 in .ts file which is like: @ViewChild(<'local reference'>, { static: true }) < name of property>, would be ElementRef.
 Which HTMLElementInput is element itself but ElementRef is a reference to that element not the element itself.
 So if you want to specify the type of those properties in .ts file, you need to first import that type from '@angular/core'.
 Although the ElementRef type is not the element itself, but we can solve it and actually get access to element itself by using
 the property which is the type of ElementRef and then use nativeElement property on it.
 So with nativeElement property we get DIRECT access to
 elements in DOM by using @ViewChild() decorator, which wasn't possible before by using just the property in .ts with type
 of ElementRef alone.

 When you add @ViewChild() on a property, the type of that property would be ElementRef and the properties that have ElementRef
 type, have a useful special property called nativeElement property. With this property we can get access to underlying element.

 So now without 2-way binding and by using local references passed to .ts methods or by getting local references in @ViewChild() ,
 our app works again.
 It's better not to change the element through using @ViewChild() and it's property. So you shouldn't access DOM through this
 approach. Because angular offers you a better way of accessing DOM with directives. So generally you should use string interpolation
 pr property binding if you want to output something in DOM and you shouldn't mess with any element itself if you even CAN do it through
 angular.
 -->
<!-- Another way of passing data around:
 Everything you place between opening and closing tag of your own component is lost by default (is simply removed from the DOM.) and
 angular won't even care about it.
 For example:
 <app-server>
    <div>...</div>
    <div>...</div>
    <div>...</div>
 </app-server>

  So all of the 3 divs and their content won't be in DOM.
  But you can change this behavior. We can use a special directive (it's directive even though it's looks like a component, but
  it doesn't have it's own template) and you can add this directive where the codes that you placed in between of opening and
  closing tag of component, would be actually.
  So imagine you want to put that p element where you USE the component itself.
  First cut and paste that p element in between <app-server> tags. But right now it doesn't displayed on the page. Because
  by default we can't put anything in between where we use our component.
  For fixing that, we place <ng-content> opening and closing tags where the <p> elements where.
  <ng-content> serves as a hook where you can place in your component template

  server-component.html :
  ...
  <p>
  </p>
  ...

  app.component.html :
  ...
  <app-server>

  </app-server>
  ...
  -->

<app-header></app-header>
<div class="container">
  <div class="row">
    <div class="col-md-12">
      <app-recipes>

      </app-recipes>
      <app-shopping-list>

      </app-shopping-list>
    </div>
  </div>
</div>




